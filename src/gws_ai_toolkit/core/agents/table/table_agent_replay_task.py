"""
[Generated by Task Expert Agent]

TableAgentReplay task that replays chat messages through the TableAgentAI to generate multiple tables.

This task takes a ResourceSet containing tables and a list of chat messages (as JSON),
then replays those messages through the TableAgentAI to reproduce the transformation
and plotting operations, resulting in a ResourceSet with multiple output tables.
"""

import os
from typing import cast

from gws_core import (
    ConfigParams,
    ConfigSpecs,
    DynamicInputs,
    FloatParam,
    InputSpec,
    InputSpecs,
    ListParam,
    OutputSpec,
    OutputSpecs,
    PlotlyResource,
    Resource,
    ResourceList,
    ResourceSet,
    StrParam,
    Table,
    Task,
    TaskInputs,
    TaskOutputs,
    task_decorator,
)
from pydantic import TypeAdapter

from gws_ai_toolkit.core.agents.table.table_agent_ai import TableAgentAi
from gws_ai_toolkit.core.agents.table.table_agent_ai_events import SerializableTableAgentEvent, TableAgentEvent
from gws_ai_toolkit.core.agents.table.table_agent_event_base import (
    SerializableUserQueryMultiTablesEvent,
    UserQueryMultiTablesEvent,
)


@task_decorator(
    "TableAgentReplayTask",
    human_name="Table Agent Replay",
    short_description="Replay chat messages through TableAgentAI to generate multiple tables from transformations",
)
class TableAgentReplayTask(Task):
    """
    [Generated by Task Expert Agent]

    This task replays a sequence of chat messages through the **TableAgentAI** to reproduce
    table transformations and generate multiple output tables.

    ## Purpose
    The TableAgentReplay task allows you to:
    - Replay previously recorded agent interactions to reproduce transformations
    - Process tables through multiple transformation steps defined in chat messages
    - Generate multiple output tables from a single or multiple input tables
    - Reproduce deterministic data transformations for testing and validation

    ## How It Works
    1. Takes one or more input tables through dynamic inputs
    2. Accepts a list of chat messages (stored as JSON) that define transformation operations
    3. Creates a TableAgentAI instance and loads the input tables
    4. Replays the event sequence through the agent
    5. Collects all transformed tables produced during replay
    6. Returns a ResourceSet containing all output tables

    ## Input
    - Dynamic inputs: Multiple Table resources can be connected as inputs
      - Each table should have a unique name
      - The table names must match those referenced in the chat messages
      - Tables without names will be automatically named as "table_0", "table_1", etc.

    ## Configuration
    - **chat_messages**: A JSON list representing AgentEventListDTOConv objects
      - Each conversation contains a user_query dict and a list of event dicts
      - Format: [{"user_query": {...}, "events": [event1, event2, ...]}, ...]
      - The user_query is deserialized to UserQueryMultiTablesEvent
      - Events define the sequence of transformations to apply for each conversation
      - Can be obtained from previous TableAgentAI runs using get_serialized_events_2()

    ## Output
    - **output_resource_set**: A ResourceSet containing only newly generated/transformed tables
      - Includes transformed tables from TableTransformEvent operations
      - Includes tables from MultiTableTransformEvent operations
      - Each table retains its name from the transformation process
      - **Note**: Input tables are NOT included in the output (only new/transformed tables)

    ## Example Use Cases
    - **Reproducible Transformations**: Replay a sequence of data cleaning steps
    - **Testing**: Validate that agent transformations produce expected results
    - **Batch Processing**: Apply the same transformation sequence to different datasets
    - **Documentation**: Demonstrate multi-step data transformation workflows

    ## Notes
    - Requires a valid OpenAI API key in the environment (OPENAI_API_KEY)
    - The chat messages must be compatible with the input tables
    - Only transformation events generate output tables (plots are not captured)
    - The task uses the same model and temperature settings as in the test example (gpt-4o, 0.1)
    """

    input_specs: InputSpecs = DynamicInputs(additionnal_port_spec=InputSpec(Table))

    output_specs = OutputSpecs(
        {
            "output_resource_set": OutputSpec(
                ResourceSet,
                human_name="Output Resource Set",
                short_description="ResourceSet containing all tables generated during replay",
            )
        }
    )

    config_specs = ConfigSpecs(
        {
            "serialized_events": ListParam(
                human_name="Serialized Events",
                short_description="JSON list of SerializableTableAgentEvent objects to replay",
                visibility="public",
            ),
            "model": StrParam(
                default_value="gpt-4o",
                human_name="Model",
                short_description="OpenAI model to use for replay (e.g., gpt-4o, gpt-4-turbo, gpt-3.5-turbo)",
                allowed_values=["gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo"],
            ),
            "temperature": FloatParam(
                default_value=0.1,
                human_name="Temperature",
                short_description="Temperature for the model (0.0 = deterministic, 1.0 = creative)",
                min_value=0.0,
                max_value=2.0,
            ),
        }
    )

    def run(self, params: ConfigParams, inputs: TaskInputs) -> TaskOutputs:
        """Execute the table agent replay process.

        Args:
            params: Configuration parameters containing the serialized events
            inputs: Task inputs containing the input tables

        Returns:
            TaskOutputs dictionary with 'output_resource_set' containing all generated tables
        """
        self.log_info_message("Starting Table Agent Replay")

        # Get input tables from dynamic inputs
        resource_list: ResourceList = inputs.get("source")

        # Convert ResourceList to dict of Tables
        input_resources: dict[str, Table] = {}
        for i, resource in enumerate(resource_list):
            if resource is not None:
                if not isinstance(resource, Table):
                    error_msg = f"Resource at index {i} is not a Table. All input resources must be Tables."
                    self.log_error_message(error_msg)
                    raise ValueError(error_msg)
                resource_name = resource.name if resource.name else f"table_{i}"
                input_resources[resource_name] = cast(Table, resource)

        self.log_info_message(f"Found {len(input_resources)} input table(s)")

        # Get serialized events from config
        serialized_events_data = params.get_value("serialized_events")

        # Parse serialized events into SerializableTableAgentEvent objects
        self.log_info_message("Parsing serialized events")
        try:
            adapter = TypeAdapter(list[SerializableTableAgentEvent])
            serialized_events = adapter.validate_python(serialized_events_data)
            self.log_info_message(f"Successfully parsed {len(serialized_events)} event(s)")
        except Exception as e:
            error_msg = f"Failed to parse serialized events: {str(e)}"
            self.log_error_message(error_msg)
            raise ValueError(error_msg)

        # Get OpenAI API key from environment
        openai_api_key = os.getenv("OPENAI_API_KEY", "")
        if not openai_api_key:
            error_msg = "OPENAI_API_KEY environment variable is not set"
            self.log_error_message(error_msg)
            raise ValueError(error_msg)

        # Get model and temperature from config
        model = params.get_value("model")
        temperature = params.get_value("temperature")

        # Create TableAgentAi instance
        self.log_info_message(f"Initializing TableAgentAI with model={model}, temperature={temperature}")

        replay_agent = TableAgentAi(
            openai_api_key=openai_api_key,
            model=model,
            temperature=temperature,
        )

        # Replay events and collect transformed tables
        self.log_info_message("Replaying events")
        self.update_progress_value(30, "Replaying events")

        try:
            output_resources = self._replay_with_progressive_deserialization(
                replay_agent, serialized_events, input_resources
            )
            self.log_success_message("Successfully replayed all events")
        except Exception as e:
            error_msg = f"Error during event replay: {str(e)}"
            self.log_error_message(error_msg)
            raise RuntimeError(error_msg) from e

        # Create output resource set with transformed tables (exclude unchanged input tables)
        output_resource_set = ResourceSet()
        for resource_name, resource in output_resources.items():
            # Only include tables that are new or different from input tables
            if resource_name not in input_resources or resource is not input_resources[resource_name]:
                output_resource_set.add_resource(resource, unique_name=resource_name)

        self.update_progress_value(100, "Replay completed")
        self.log_success_message(f"Table Agent Replay completed with {len(output_resource_set)} output table(s)")

        return {"output_resource_set": output_resource_set}

    def _replay_with_progressive_deserialization(
        self,
        agent: TableAgentAi,
        serialized_events: list[SerializableTableAgentEvent],
        input_tables: dict[str, Table],
    ) -> dict[str, Resource]:
        """Replay events with progressive deserialization.

        This method deserializes and replays events in chunks separated by UserQuery events.
        After each chunk is replayed, the table dictionary is updated with newly created tables,
        allowing subsequent UserQuery events to reference these new tables.

        Args:
            agent: The TableAgentAi instance to use for replay
            serialized_events: List of serialized events to replay
            input_tables: Dictionary of input tables

        Returns:
            Dictionary of all output resources (tables + plots)
        """
        # Track available tables (starts with input tables, grows as transformations occur)
        available_tables = input_tables.copy()

        # Group events into chunks separated by UserQuery events
        event_chunks: list[list[SerializableTableAgentEvent]] = []
        current_chunk: list[SerializableTableAgentEvent] = []

        for serialized_event in serialized_events:
            if isinstance(serialized_event, SerializableUserQueryMultiTablesEvent):
                # If we have a previous chunk, save it
                if current_chunk:
                    event_chunks.append(current_chunk)
                # Start new chunk with this user query
                current_chunk = [serialized_event]
            else:
                current_chunk.append(serialized_event)

        # Add the last chunk
        if current_chunk:
            event_chunks.append(current_chunk)

        # Process each chunk
        for i, chunk in enumerate(event_chunks):
            self.log_info_message(f"Processing event chunk {i + 1}/{len(event_chunks)}")

            # Deserialize this chunk with current available tables
            runtime_chunk = self._deserialize_chunk(chunk, available_tables)

            # Replay this chunk
            list(agent.replay_events(runtime_chunk))

            # Extract newly created tables from replayed events
            available_tables.update(agent.get_output_tables())

        # Collect all output resources
        output_resources: dict[str, Resource] = cast(dict[str, Resource], agent.get_output_tables())

        for key, figure in agent.get_output_plots().items():
            output_resources[key] = PlotlyResource(figure=figure)

        return output_resources

    def _deserialize_chunk(
        self,
        chunk: list[SerializableTableAgentEvent],
        available_tables: dict[str, Table],
    ) -> list[TableAgentEvent]:
        """Deserialize a chunk of serialized events to runtime events.

        Args:
            chunk: List of serialized events in this chunk
            available_tables: Dictionary of currently available tables

        Returns:
            List of runtime events
        """
        runtime_events: list[TableAgentEvent] = []

        for serialized_event in chunk:
            # Handle UserQuery events - convert to runtime with current available tables
            if isinstance(serialized_event, SerializableUserQueryMultiTablesEvent):
                runtime_event = UserQueryMultiTablesEvent.from_serializable(serialized_event, available_tables)
                runtime_events.append(runtime_event)

            # For other serializable events (FunctionCallEvent, etc.), they're already runtime-compatible
            else:
                runtime_events.append(serialized_event)

        return runtime_events
