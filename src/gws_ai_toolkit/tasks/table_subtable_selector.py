from typing import cast

from gws_core import (
    BoolParam,
    ConfigParams,
    ConfigSpecs,
    IntParam,
    ListParam,
    Table,
    TaskRunner,
    Transformer,
    transformer_decorator,
)


@transformer_decorator(
    unique_name="TableSubtableSelector",
    resource_type=Table,
    short_description="Select a subtable by row and column ranges",
)
class TableSubtableSelector(Transformer):
    """
    [Generated by Task Expert Agent]

    Select a subtable from a table using row and column index ranges.

    This transformer allows you to extract a rectangular subset of a table by specifying:
    - Row range (start and end indices)
    - Column selection (specific column names or all columns)
    - Optional header handling (use first row of selection as new header)

    ## Usage
    - **Input**: A Table resource
    - **Output**: A Table resource containing the selected subtable

    ## Configuration
    - **start_row**: Starting row index (0-based, inclusive)
    - **end_row**: Ending row index (0-based, inclusive)
    - **columns**: List of column names to select (empty = all columns)
    - **use_first_row_as_header**: If true, the first row of the selection becomes the header

    ## Notes
    - Row indices are 0-based (first row is 0)
    - If start_row > end_row, they will be automatically swapped
    - If no columns are specified, all columns are selected
    - When using first row as header, it's removed from the data rows

    ## Example
    To select rows 5-10 and columns ["A", "B", "C"]:
    - start_row: 5
    - end_row: 10
    - columns: ["A", "B", "C"]
    """

    config_specs = ConfigSpecs(
        {
            "start_row": IntParam(
                default_value=0,
                min_value=0,
                human_name="Start row",
                short_description="Starting row index (0-based, inclusive)",
            ),
            "end_row": IntParam(
                default_value=0,
                min_value=0,
                human_name="End row",
                short_description="Ending row index (0-based, inclusive)",
            ),
            "columns": ListParam(
                optional=True,
                human_name="Columns",
                short_description="List of column names to select (empty = all columns)",
            ),
            "use_first_row_as_header": BoolParam(
                default_value=False,
                human_name="Use first row as header",
                short_description="If true, use the first row of selection as column headers",
            ),
        }
    )

    def transform(self, source: Table, params: ConfigParams) -> Table:
        # Get parameters
        start_row: int = params.get_value("start_row")
        end_row: int = params.get_value("end_row")
        columns: list[str] | None = params.get_value("columns")
        use_first_row_as_header: bool = params.get_value("use_first_row_as_header")

        # Log the operation
        self.log_info_message(f"Selecting subtable from row {start_row} to {end_row}")

        # Get the source dataframe
        source_df = source.get_data()

        if source_df is None or source_df.empty:
            self.log_warning_message("Source table is empty")
            return Table()

        # Handle inverted selection (when start > end)
        if start_row > end_row:
            self.log_info_message(f"Swapping start_row ({start_row}) and end_row ({end_row})")
            start_row, end_row = end_row, start_row

        # Validate row indices
        max_row_index = len(source_df) - 1
        if start_row > max_row_index:
            self.log_warning_message(
                f"start_row ({start_row}) exceeds table size ({max_row_index}). "
                "Using last row as start."
            )
            start_row = max_row_index

        if end_row > max_row_index:
            self.log_warning_message(
                f"end_row ({end_row}) exceeds table size ({max_row_index}). Using last row as end."
            )
            end_row = max_row_index

        # Extract the subset of data
        if columns and len(columns) > 0:
            # Validate column names
            valid_columns = [col for col in columns if col in source_df.columns]
            invalid_columns = [col for col in columns if col not in source_df.columns]

            if invalid_columns:
                self.log_warning_message(f"Invalid column names will be ignored: {invalid_columns}")

            if not valid_columns:
                self.log_error_message("No valid columns specified")
                return Table()

            # Select specific columns and rows
            selected_data = source_df.iloc[start_row : end_row + 1][valid_columns]
            self.log_info_message(f"Selected {len(valid_columns)} columns: {valid_columns}")
        else:
            # Select all columns for the row range
            selected_data = source_df.iloc[start_row : end_row + 1]
            self.log_info_message(f"Selected all {len(source_df.columns)} columns")

        # Handle header option
        if use_first_row_as_header and not selected_data.empty:
            # Use first row as header
            new_columns = selected_data.iloc[0].values
            selected_data = selected_data.iloc[1:]
            selected_data.columns = new_columns
            self.log_info_message("Using first row as header")

        # Create result table
        result = Table(selected_data)

        # Log success
        self.log_success_message(
            f"Successfully created subtable with {len(result.get_data())} rows "
            f"and {len(result.get_data().columns)} columns"
        )

        return result

    @staticmethod
    def select_subtable(
        source_table: Table,
        start_row: int,
        end_row: int,
        columns: list[str] | None = None,
        use_first_row_as_header: bool = False,
    ) -> Table:
        """
        Static method to select a subtable with typed parameters.

        This provides a convenient, type-safe way to call the TableSubtableSelector task
        without manually constructing TaskRunner parameters.

        Args:
            source_table: The source Table to extract from
            start_row: Starting row index (0-based, inclusive)
            end_row: Ending row index (0-based, inclusive)
            columns: Optional list of column names to select. If None or empty, all columns are selected
            use_first_row_as_header: If True, use the first row of selection as column headers

        Returns:
            Table: The extracted subtable

        Example:
            ```python
            # Select rows 5-10 with columns A, B, C
            subtable = TableSubtableSelector.select_subtable(
                source_table=my_table,
                start_row=5,
                end_row=10,
                columns=["A", "B", "C"]
            )

            # Select all columns for rows 0-5, using first row as header
            subtable = TableSubtableSelector.select_subtable(
                source_table=my_table,
                start_row=0,
                end_row=5,
                use_first_row_as_header=True
            )
            ```
        """
        runner = TaskRunner(
            task_type=TableSubtableSelector,
            params={
                "start_row": start_row,
                "end_row": end_row,
                "columns": columns,
                "use_first_row_as_header": use_first_row_as_header,
            },
            inputs={TableSubtableSelector.input_name: source_table},
        )
        outputs = runner.run()
        return cast(Table, outputs[TableSubtableSelector.output_name])
